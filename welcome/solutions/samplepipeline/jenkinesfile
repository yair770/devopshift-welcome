# Check if virtualenv is installed
if ! command -v virtualenv &> /dev/null; then
    echo "virtualenv not found. Installing using pip..."
    pip install virtualenv
else
    echo "virtualenv is already installed."
fi

# Activate the virtual environment
PYENV_HOME=$WORKSPACE/.pyenv/

# Delete previously built virtualenv
if [ -d $PYENV_HOME ]; then
    rm -rf $PYENV_HOME
fi

# Create virtualenv and install necessary packages
virtualenv $PYENV_HOME
. $PYENV_HOME/bin/activate

# Install required Python packages
pip install -r requirements.txt

# Set up Flask environment variables
export FLASK_APP=run.py
export FLASK_ENV=development

# Debug: List all environment variables
echo "Current environment variables:"
env

# Check if the Flask app is already running and stop it
echo "Checking if the Flask app is already running and stop it"
tasks=$(pgrep -f "flask run" || true)

if [ -n "$tasks" ]; then
    echo "Stopping existing Flask applications..."
    for pid in $tasks; do
        kill -9 $pid
        echo "Killed process $pid"
    done
else
    echo "No Flask application running."
fi

# Start the Flask application in the background with nohup and redirect output to a log file
echo "Starting Flask application on 0.0.0.0:5005..."
nohup flask run --host=0.0.0.0 --port=5005  > flask_app.log 2>&1 &

# Disown the process to prevent it from being terminated when Jenkins job ends
# disown

# Sleep for a few seconds to allow Flask to start
sleep 5

# Check if the Flask application is running
tasks=$(pgrep -f "flask run")

# Debug: Print all running processes to check if flask run is listed
echo "Running processes:"
ps aux

if [ -z "$tasks" ]; then
    echo "Flask application is not running!"
    exit 1
else
    echo "Flask application is running successfully using port 5005 ."
    echo "Terminating application before exit to make sure no memory leak from triggered job appears in the system ."
fi
